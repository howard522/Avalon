// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'role.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$Role {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Role);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role()';
}


}

/// @nodoc
class $RoleCopyWith<$Res>  {
$RoleCopyWith(Role _, $Res Function(Role) __);
}


/// Adds pattern-matching-related methods to [Role].
extension RolePatterns on Role {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( Merlin value)?  merlin,TResult Function( Percival value)?  percival,TResult Function( LoyalServant value)?  loyalServant,TResult Function( Assassin value)?  assassin,TResult Function( Morgana value)?  morgana,TResult Function( Mordred value)?  mordred,TResult Function( Oberon value)?  oberon,TResult Function( MinionOfMordred value)?  minion,required TResult orElse(),}){
final _that = this;
switch (_that) {
case Merlin() when merlin != null:
return merlin(_that);case Percival() when percival != null:
return percival(_that);case LoyalServant() when loyalServant != null:
return loyalServant(_that);case Assassin() when assassin != null:
return assassin(_that);case Morgana() when morgana != null:
return morgana(_that);case Mordred() when mordred != null:
return mordred(_that);case Oberon() when oberon != null:
return oberon(_that);case MinionOfMordred() when minion != null:
return minion(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( Merlin value)  merlin,required TResult Function( Percival value)  percival,required TResult Function( LoyalServant value)  loyalServant,required TResult Function( Assassin value)  assassin,required TResult Function( Morgana value)  morgana,required TResult Function( Mordred value)  mordred,required TResult Function( Oberon value)  oberon,required TResult Function( MinionOfMordred value)  minion,}){
final _that = this;
switch (_that) {
case Merlin():
return merlin(_that);case Percival():
return percival(_that);case LoyalServant():
return loyalServant(_that);case Assassin():
return assassin(_that);case Morgana():
return morgana(_that);case Mordred():
return mordred(_that);case Oberon():
return oberon(_that);case MinionOfMordred():
return minion(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( Merlin value)?  merlin,TResult? Function( Percival value)?  percival,TResult? Function( LoyalServant value)?  loyalServant,TResult? Function( Assassin value)?  assassin,TResult? Function( Morgana value)?  morgana,TResult? Function( Mordred value)?  mordred,TResult? Function( Oberon value)?  oberon,TResult? Function( MinionOfMordred value)?  minion,}){
final _that = this;
switch (_that) {
case Merlin() when merlin != null:
return merlin(_that);case Percival() when percival != null:
return percival(_that);case LoyalServant() when loyalServant != null:
return loyalServant(_that);case Assassin() when assassin != null:
return assassin(_that);case Morgana() when morgana != null:
return morgana(_that);case Mordred() when mordred != null:
return mordred(_that);case Oberon() when oberon != null:
return oberon(_that);case MinionOfMordred() when minion != null:
return minion(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  merlin,TResult Function()?  percival,TResult Function()?  loyalServant,TResult Function()?  assassin,TResult Function()?  morgana,TResult Function()?  mordred,TResult Function()?  oberon,TResult Function()?  minion,required TResult orElse(),}) {final _that = this;
switch (_that) {
case Merlin() when merlin != null:
return merlin();case Percival() when percival != null:
return percival();case LoyalServant() when loyalServant != null:
return loyalServant();case Assassin() when assassin != null:
return assassin();case Morgana() when morgana != null:
return morgana();case Mordred() when mordred != null:
return mordred();case Oberon() when oberon != null:
return oberon();case MinionOfMordred() when minion != null:
return minion();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  merlin,required TResult Function()  percival,required TResult Function()  loyalServant,required TResult Function()  assassin,required TResult Function()  morgana,required TResult Function()  mordred,required TResult Function()  oberon,required TResult Function()  minion,}) {final _that = this;
switch (_that) {
case Merlin():
return merlin();case Percival():
return percival();case LoyalServant():
return loyalServant();case Assassin():
return assassin();case Morgana():
return morgana();case Mordred():
return mordred();case Oberon():
return oberon();case MinionOfMordred():
return minion();}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  merlin,TResult? Function()?  percival,TResult? Function()?  loyalServant,TResult? Function()?  assassin,TResult? Function()?  morgana,TResult? Function()?  mordred,TResult? Function()?  oberon,TResult? Function()?  minion,}) {final _that = this;
switch (_that) {
case Merlin() when merlin != null:
return merlin();case Percival() when percival != null:
return percival();case LoyalServant() when loyalServant != null:
return loyalServant();case Assassin() when assassin != null:
return assassin();case Morgana() when morgana != null:
return morgana();case Mordred() when mordred != null:
return mordred();case Oberon() when oberon != null:
return oberon();case MinionOfMordred() when minion != null:
return minion();case _:
  return null;

}
}

}

/// @nodoc


class Merlin extends Role {
  const Merlin(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Merlin);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.merlin()';
}


}




/// @nodoc


class Percival extends Role {
  const Percival(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Percival);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.percival()';
}


}




/// @nodoc


class LoyalServant extends Role {
  const LoyalServant(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoyalServant);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.loyalServant()';
}


}




/// @nodoc


class Assassin extends Role {
  const Assassin(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Assassin);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.assassin()';
}


}




/// @nodoc


class Morgana extends Role {
  const Morgana(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Morgana);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.morgana()';
}


}




/// @nodoc


class Mordred extends Role {
  const Mordred(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Mordred);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.mordred()';
}


}




/// @nodoc


class Oberon extends Role {
  const Oberon(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Oberon);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.oberon()';
}


}




/// @nodoc


class MinionOfMordred extends Role {
  const MinionOfMordred(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MinionOfMordred);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Role.minion()';
}


}




// dart format on
